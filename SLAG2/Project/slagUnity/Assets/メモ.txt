・process -> New class へ
・外部からの関数実行　
・外部からの変数値参照・値変更・新規・削除

・loction -> poinervariable ポインタ変数に変更 pointervar


・YVALUE の o には、大文字強制まえの文字が入っているようにしよう。

・デバッグの回収
  1. ファイルＩＤの導入 --- 複数ファイルに対応
  2. ブレイクポインタは、ファイルＩＤと行番号
  
・複数ファイルの対応
  複数ファイルをロードできる。

・3項演算子の導入 -- 失敗
  a ? b : c

・ハンドル形式にかえようか・・・　それともYValueを返却する？
  var wd = load(src,id);   idはデバッグ時の識別に使用。
  wd.run();
  こんな具合に。

・Unity用の初期化を考えないと・・・ 再初期化ができるように・・・

・スピード 遅い。当然。

・メモリ GCが多い。update悲惨。

・コメントアウト /* */がないと不便。

・Update中の例外処理を 例外キャッチー＞アップデートをDisableへ

・セミコロンエラー検出が遅い。

・デモ　ストップウォッチ

・マイナスの認識ができない。


前付き + - ! ~ ^ ++ -- →先頭時。2項演算子の後    op expr で振るう。
後付き ++ -            →後尾時。２項演算子の前。 expr op で振るう。
特殊  ? :              →3項演算子  expr ? expr : expr    で振るう。 

TokenProvder通過後に オペレータとexprの塊になっている。
例）
op expr op expr op op expr op

これで、前付き・後付きの条件で分割する。

    
計算式

１．演算子で分割された要素を解析
２．ポインタ変数要素を解析
３．前置演算子要素を解析
４．後置演算子要素を解析
５．三項演算子要素を解析

USE_TRY でエクセプション回避いれた。

終了ができない？ --> FilePipeのみ可能。

NamedPipeは終了問題が解決できないので使用不可。

メソッド検索時にFloat,Doubleを同意として扱う。 それをUnityだけとすればよい！　そうすれば、通常はDoubleとなり有効数字が15 (Singleは７)
-- メソッドサーチの問題が残るのみ。

次はこんな仕様

var h = hashtable();
h.v = 10;
h.l = [];

---

ログ関数は分かり易くファイル名で表示しておく

---

インスタンス時もタイプチェック必須。コンバートもやろう！

https://msdn.microsoft.com/en-us/library/h93ya84h(v=vs.110).aspx


---

エラー文言確認せよ。 <------------------ ※重要

---

v.s = "." 等は、まずいんじゃないか？　定義名等がスクリプトで使用できない <------------------------------- ※ 
                                      実行中は大文字のみだから心配ないかも。
---

util.isNumericType() <--------------- 作成せよ。

---

ARRAY と LIST を.NETにあわせろ！

JSにあわせようとしたけど、実行はＣ＃だから概念はＣ＃にあわせるべきだと今は思う。  --> DONE!

---

ステートマシンを再考

var sm = StateMachine();  
sm.Goto("");

var sm = StateMachine(gameObject);

---

複数ファイルへの対応
YVALUEに file_idを追加

---

デバッガ！
load a.js b.js c.js を可能にする。
順にidが0,1,2と振られる
モニターのソース名がリストボックス
ソースは行番号付きで出力。


---
ここにきて大問題。

やはり、Sleepは使えない。

実行部分は裏スレッドへ

Unity由来の命令は表でやる仕組みを・・・

Main Thread
   |
   V
  request
   a = func(object list)
  done
   
遅そうだからデバッグ時にのみ有効になる仕組みでよいかも。

まずは現在のままで Unity由来のみを別スレッドで実行する仕組みを。


